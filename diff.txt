diff --git a/TodoPad.xcodeproj/project.pbxproj b/TodoPad.xcodeproj/project.pbxproj
index 0ebb16a..a1de751 100644
--- a/TodoPad.xcodeproj/project.pbxproj
+++ b/TodoPad.xcodeproj/project.pbxproj
@@ -44,6 +44,8 @@
 		8E2B2BD8289DC36400DC1D4D /* RepeatSettingsTests.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8E2B2BD7289DC36400DC1D4D /* RepeatSettingsTests.swift */; };
 		8E2B2BDA289DD77400DC1D4D /* PersistentTaskTests.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8E2B2BD9289DD77400DC1D4D /* PersistentTaskTests.swift */; };
 		8E2B2BDC289E373100DC1D4D /* TaskFormModelTests.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8E2B2BDB289E373100DC1D4D /* TaskFormModelTests.swift */; };
+		8E2DE5D928B5AA2C00EBC24A /* TaskCompletedPopup.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8E2DE5D828B5AA2C00EBC24A /* TaskCompletedPopup.swift */; };
+		8E2DE5DB28B5AA5700EBC24A /* TaskCompletedPopupTests.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8E2DE5DA28B5AA5700EBC24A /* TaskCompletedPopupTests.swift */; };
 		8E36705E28B3EA5F0056D92F /* SettingsController.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8E36705D28B3EA5F0056D92F /* SettingsController.swift */; };
 		8E36706128B3EBFB0056D92F /* SettingsControllerTests.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8E36706028B3EBFB0056D92F /* SettingsControllerTests.swift */; };
 		8E36706328B3EC9E0056D92F /* SettingsCellModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8E36706228B3EC9E0056D92F /* SettingsCellModel.swift */; };
@@ -176,6 +178,8 @@
 		8E2B2BD7289DC36400DC1D4D /* RepeatSettingsTests.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = RepeatSettingsTests.swift; sourceTree = "<group>"; };
 		8E2B2BD9289DD77400DC1D4D /* PersistentTaskTests.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PersistentTaskTests.swift; sourceTree = "<group>"; };
 		8E2B2BDB289E373100DC1D4D /* TaskFormModelTests.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = TaskFormModelTests.swift; sourceTree = "<group>"; };
+		8E2DE5D828B5AA2C00EBC24A /* TaskCompletedPopup.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = TaskCompletedPopup.swift; sourceTree = "<group>"; };
+		8E2DE5DA28B5AA5700EBC24A /* TaskCompletedPopupTests.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = TaskCompletedPopupTests.swift; sourceTree = "<group>"; };
 		8E36705D28B3EA5F0056D92F /* SettingsController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SettingsController.swift; sourceTree = "<group>"; };
 		8E36706028B3EBFB0056D92F /* SettingsControllerTests.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SettingsControllerTests.swift; sourceTree = "<group>"; };
 		8E36706228B3EC9E0056D92F /* SettingsCellModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SettingsCellModel.swift; sourceTree = "<group>"; };
@@ -346,6 +350,7 @@
 			children = (
 				8E2B2BB3289CB02F00DC1D4D /* SpyNavigationController.swift */,
 				8E7FAFB9289A16BB00E0CF58 /* TabBarControllerTests.swift */,
+				8E2DE5DA28B5AA5700EBC24A /* TaskCompletedPopupTests.swift */,
 				8E75D71C28AE41B400B7988B /* TaskTab */,
 				8E3FCDFA28B15E8A00034FF0 /* Helpers */,
 				8E7FAFC7289A32CB00E0CF58 /* DateScroller */,
@@ -641,6 +646,7 @@
 				8EB9605C289B7AC500D63477 /* TasksTableViewHeader.swift */,
 				8EF8610028A4FC3500FC6674 /* TaskGroupCell.swift */,
 				8E40F6D328AC20C8000E5A50 /* TaskCell.swift */,
+				8E2DE5D828B5AA2C00EBC24A /* TaskCompletedPopup.swift */,
 			);
 			path = TaskController;
 			sourceTree = "<group>";
@@ -918,6 +924,7 @@
 				8E2B2BD6289DC34600DC1D4D /* RepeatSettings.swift in Sources */,
 				8E40F6D928AC8704000E5A50 /* ViewTaskController.swift in Sources */,
 				8E0CEC1728A33FC000EFE295 /* TaskFormRepeatSettingsCell.swift in Sources */,
+				8E2DE5D928B5AA2C00EBC24A /* TaskCompletedPopup.swift in Sources */,
 				8E36706528B40A160056D92F /* WebViewerController.swift in Sources */,
 				8E7FAFC3289A1BF300E0CF58 /* Constants.swift in Sources */,
 			);
@@ -946,6 +953,7 @@
 				8E0CEC2328A39FA600EFE295 /* RepeatingDayCellTests.swift in Sources */,
 				8E2B2BBD289CCE8E00DC1D4D /* TaskFormControllerViewModelTests.swift in Sources */,
 				8E75D72728AE56AD00B7988B /* ViewTaskTableViewHeaderTests.swift in Sources */,
+				8E2DE5DB28B5AA5700EBC24A /* TaskCompletedPopupTests.swift in Sources */,
 				8E40F6DB28AC948A000E5A50 /* MockTasksController.swift in Sources */,
 				8E3FCDFC28B15EA800034FF0 /* NotificationManagerTests.swift in Sources */,
 				8E0CEC1B28A357CD00EFE295 /* MockTaskFormRepeatSettingsCellDelegate.swift in Sources */,
diff --git a/TodoPad.xcodeproj/project.xcworkspace/xcuserdata/jacoberceg.xcuserdatad/UserInterfaceState.xcuserstate b/TodoPad.xcodeproj/project.xcworkspace/xcuserdata/jacoberceg.xcuserdatad/UserInterfaceState.xcuserstate
index 03e347e..db4867c 100644
Binary files a/TodoPad.xcodeproj/project.xcworkspace/xcuserdata/jacoberceg.xcuserdatad/UserInterfaceState.xcuserstate and b/TodoPad.xcodeproj/project.xcworkspace/xcuserdata/jacoberceg.xcuserdatad/UserInterfaceState.xcuserstate differ
diff --git a/TodoPad/CoreData/RepeatingTaskManager.swift b/TodoPad/CoreData/RepeatingTaskManager.swift
index 7bd9473..6e2bd2d 100644
--- a/TodoPad/CoreData/RepeatingTaskManager.swift
+++ b/TodoPad/CoreData/RepeatingTaskManager.swift
@@ -163,7 +163,12 @@ extension RepeatingTaskManager {
         self.saveContext()
     }
     
-    public func deleteCompletedRepeatingTask(with task: RepeatingTask, for date: Date) {
+    
+    /// Deleted the CompletedTask for the given day, for the given RepeatingTask, making it not completed.
+    /// - Parameters:
+    ///   - task: The RepeatingTask
+    ///   - date: The date to delete the CompletedTask for the RepeatingTask
+    public func setTaskNotCompleted(with task: RepeatingTask, for date: Date) {
         if let completedTask = self.loadCompletedRepeatingTasks(with: task, for: date) {
             self.context.delete(completedTask)
             self.saveContext()
diff --git a/TodoPad/Helpers/AlertManager.swift b/TodoPad/Helpers/AlertManager.swift
index 36c8e50..b188d3a 100644
--- a/TodoPad/Helpers/AlertManager.swift
+++ b/TodoPad/Helpers/AlertManager.swift
@@ -73,6 +73,34 @@ extension AlertManager {
         )
     }
     
+    /// A warning against permanently deleting a NonRepeating or Persistent task.
+    /// - Parameters:
+    ///   - completion: Boolean True to delete task. Boolean False to cancel.
+    public static func showDeleteTaskWarning(on vc: UIViewController, completion: @escaping (Bool)->()) {
+        self.showDestructiveAlert(
+            on: vc,
+            title: "Are you sure you want to delete this task?",
+            message: nil,
+            completion: completion
+        )
+    }
+    
+    /// A warning against completely deleting a Repeating task including all past completed days.
+    /// - Parameters:
+    ///   - completion: Boolean True to delete task. Boolean False to cancel.
+    public static func showCompletelyDeleteRepeatingTaskWarning(on vc: UIViewController, completion: @escaping (Bool)->()) {
+        self.showDestructiveAlert(
+            on: vc,
+            title: "Are you sure?",
+            message: "All previously completed days will be deleted for this task. You will be unable to recover the task.",
+            completion: completion
+        )
+    }
+    
+    
+    /// A warning against permanently deleting ALL tasks from core data
+    /// - Parameters:
+    ///   - completion: Boolean True to delete all tasks. Boolean False to cancel.
     public static func showDeleteAllTaskskWarning(on vc: UIViewController, completion: @escaping (Bool)->()) {
         self.showDestructiveAlert(
             on: vc,
@@ -81,5 +109,53 @@ extension AlertManager {
             completion: completion
         )
     }
+}
+
+
+// MARK: - Options Alerts
+extension AlertManager {
+    
+    /// A helper funtion to show an alert with different action buttons.
+    /// - Parameters:
+    ///   - vc: The UIViewController that you wish to display the alert on.
+    ///   - title: The title for the alert.
+    ///   - message: A optional additional message for the alert.
+    ///   - actions: An array of UIAlertAction's to add to the alert.
+    private static func showActionAlert(on vc: UIViewController, title: String, message: String? = nil, actions: [UIAlertAction]) {
+        let alert = UIAlertController(title: title, message: message, preferredStyle: .alert)
+        
+        for action in actions {
+            alert.addAction(action)
+        }
+        
+        DispatchQueue.main.async {
+            vc.present(alert, animated: true, completion: nil)
+        }
+    }
+    
+    
+    /// An alert to choose how the user wants to delete a task.
+    /// - Parameters:
+    ///   - completion: AlertManager.DeleteTaskOption Enum
+    static func showDeleteRepeatingTaskAlert(on vc: UIViewController, completion: @escaping (AlertManager.DeleteRepeatingTaskOption)->Void) {
+        let actions = [
+            UIAlertAction(title: DeleteRepeatingTaskOption.allFuture.rawValue, style: .default, handler: { alertAction in
+                completion(DeleteRepeatingTaskOption.allFuture)
+            }),
+            UIAlertAction(title: DeleteRepeatingTaskOption.allTasks.rawValue, style: .destructive, handler: { alertAction in
+                completion(DeleteRepeatingTaskOption.allTasks)
+            }),
+            UIAlertAction(title: DeleteRepeatingTaskOption.cancel.rawValue, style: .cancel, handler: { alertAction in
+                completion(DeleteRepeatingTaskOption.cancel)
+            })
+        ]
+        self.showActionAlert(on: vc, title: "Delete repeating tasks", message: nil, actions: actions)
+    }
+    
+    enum DeleteRepeatingTaskOption: String {
+        case allFuture = "This and all future tasks"
+        case allTasks = "All tasks"
+        case cancel = "Cancel"
+    }
     
 }
diff --git a/TodoPad/Supporting/Extensions/Date+Extensions.swift b/TodoPad/Supporting/Extensions/Date+Extensions.swift
index e305b38..87bc193 100644
--- a/TodoPad/Supporting/Extensions/Date+Extensions.swift
+++ b/TodoPad/Supporting/Extensions/Date+Extensions.swift
@@ -21,8 +21,8 @@ extension Date {
         
         let startOfDay = calendar.startOfDay(for: self)
         
-        let endOfDay = calendar.date(byAdding: .day, value: 1, to: startOfDay)
-        
+        var endOfDay = calendar.date(byAdding: .day, value: 1, to: startOfDay)
+        endOfDay = endOfDay?.addingTimeInterval(-1)
         return endOfDay
     }
     
diff --git a/TodoPad/TabBarController.swift b/TodoPad/TabBarController.swift
index 114f8b7..ee0ff4c 100644
--- a/TodoPad/TabBarController.swift
+++ b/TodoPad/TabBarController.swift
@@ -7,18 +7,20 @@
 
 import UIKit
 
-class TabBarController: UITabBarController {
-
+class TabBarController: UITabBarController, TasksControllerDelegate {
+    
     // MARK: - Lifecycle
     override func viewDidLoad() {
         super.viewDidLoad()
-        
-        setupViewControllers()
+        self.tabBar.backgroundColor = .dynamicColorTwo
+        self.setupViewControllers()
     }
     
     // MARK: - Helpers
     private func setupViewControllers() {
-        let tasks = self.templateNavigationController(image: UIImage(systemName: "list.bullet"), title: "Tasks", rootViewController: TasksController())
+        let tasksController = TasksController()
+                tasksController.delegate = self
+        let tasks = self.templateNavigationController(image: UIImage(systemName: "list.bullet"), title: "Tasks", rootViewController: tasksController)
         
         let stats = self.templateNavigationController(image: UIImage(systemName: "chart.bar.fill"), title: "Stats", rootViewController: StatsController())
         
@@ -34,4 +36,60 @@ class TabBarController: UITabBarController {
         return nav
     }
     
+    // MARK: - Show Task Completed Popup
+    var taskCountAnimationArray: [Int] = []
+    var animationInProg = false
+    
+    // Delegate Callback Function
+    func showTaskCompletedPopup() {
+        //        let vm = StatsControllerViewModel()
+        //        vm.fetchData()
+        //        let taskCount = vm.fetchTotalTasksCompletedCount()
+        //        // Add taskCount to queue
+        //        self.taskCountAnimationArray.append(taskCount)
+        //
+        //        // Block if animating... it will call itself if taskCount in queue
+        //        if animationInProg != true {
+        //            self.doAnimation()
+        //        }
+    }
+    
+    //    private func doAnimation()  {
+    //        guard taskCountAnimationArray.count > 0 else { return }
+    //        // Set true to block from animating twice at a time
+    //        animationInProg = true
+    //
+    //        let tCompView = TaskCompletedPopup()
+    //        tCompView.configure(tasksCompleted: taskCountAnimationArray.first!)
+    //
+    //        self.view.addSubview(tCompView)
+    //        tCompView.frame = CGRect(x: self.view.width/10, y: self.view.height, width: self.view.width*0.8, height: 68)
+    //
+    //        DispatchQueue.main.async { [weak self] in
+    //            UIView.animate(withDuration: 1) {
+    //                tCompView.transform = CGAffineTransform(translationX: 0, y: -190)
+    //            } completion: { [weak self] done in
+    //                if done {
+    //                    DispatchQueue.main.asyncAfter(deadline: .now()+2) { [weak self] in
+    //                        UIView.animate(withDuration: 1) {
+    //                            tCompView.transform = .identity
+    //                        } completion: { done in
+    //                            if done {
+    //                                tCompView.removeFromSuperview()
+    //                                // Remove current taskCount from queue and stop blocking animation
+    //                                self?.taskCountAnimationArray.removeFirst()
+    //                                self?.animationInProg = false
+    //
+    //                                // If queue still has taskCounts queued, do animation
+    //                                if let _ = self?.taskCountAnimationArray.first {
+    //                                    self?.doAnimation()
+    //                                }
+    //                            }
+    //                        }
+    //                    }
+    //                }
+    //            }
+    //        }
+    //    }
+    
 }
diff --git a/TodoPad/Task Tab/TaskController/TaskCompletedPopup.swift b/TodoPad/Task Tab/TaskController/TaskCompletedPopup.swift
index 2d19863..a6f8fc7 100644
--- a/TodoPad/Task Tab/TaskController/TaskCompletedPopup.swift	
+++ b/TodoPad/Task Tab/TaskController/TaskCompletedPopup.swift	
@@ -5,4 +5,62 @@
 //  Created by John Lee on 2022-08-23.
 //
 
-import Foundation
+import UIKit
+
+class TaskCompletedPopup: UIView {
+    
+    // MARK: - UI Components
+    private let flameImageView: UIImageView = {
+        let iv = UIImageView()
+        iv.contentMode = .scaleAspectFit
+        iv.image = UIImage(systemName: "flame.fill")//?.withTintColor(.systemOrange, renderingMode: .automatic)
+        iv.tintColor = .systemOrange
+        return iv
+    }()
+    
+    let tasksCompletedLabel: UILabel = {
+        let label = UILabel()
+        label.textColor = .systemOrange
+        label.textAlignment = .center
+        label.font = .systemFont(ofSize: 26, weight: .bold)
+        label.text = "-1 Tasks Completed"
+        return label
+    }()
+    
+    // MARK: - Lifecycle
+    override init(frame: CGRect) {
+        super.init(frame: frame)
+        self.setupUI()
+    }
+    
+    required init?(coder: NSCoder) {
+        fatalError("init(coder:) has not been implemented")
+    }
+    
+    public func configure(tasksCompleted: Int) {
+        self.tasksCompletedLabel.text = "\(tasksCompleted) Tasks Completed"
+    }
+    
+    // MARK: - UI Setup
+    private func setupUI() {
+        self.layer.cornerRadius = 21
+        self.backgroundColor = .rgb(red: 119, green: 58, blue: 58, alpha: 1)
+        
+        self.addSubview(flameImageView)
+        self.addSubview(tasksCompletedLabel)
+
+        flameImageView.translatesAutoresizingMaskIntoConstraints = false
+        tasksCompletedLabel.translatesAutoresizingMaskIntoConstraints = false
+
+        NSLayoutConstraint.activate([
+            flameImageView.leadingAnchor.constraint(equalTo: layoutMarginsGuide.leadingAnchor),
+            flameImageView.centerYAnchor.constraint(equalTo: centerYAnchor),
+            flameImageView.widthAnchor.constraint(equalToConstant: 44),
+            flameImageView.heightAnchor.constraint(equalToConstant: 44),
+
+            tasksCompletedLabel.leadingAnchor.constraint(equalTo: flameImageView.trailingAnchor),
+            tasksCompletedLabel.trailingAnchor.constraint(equalTo: layoutMarginsGuide.trailingAnchor),
+            tasksCompletedLabel.centerYAnchor.constraint(equalTo: centerYAnchor),
+        ])
+    }
+}
diff --git a/TodoPad/Task Tab/TaskController/TasksController.swift b/TodoPad/Task Tab/TaskController/TasksController.swift
index cca59d2..60225ea 100644
--- a/TodoPad/Task Tab/TaskController/TasksController.swift	
+++ b/TodoPad/Task Tab/TaskController/TasksController.swift	
@@ -8,7 +8,7 @@
 import UIKit
 
 protocol TasksControllerDelegate: AnyObject {
-    func showTasksCompletedPopup()
+    func showTaskCompletedPopup()
 }
 
 class TasksController: UIViewController {
@@ -58,8 +58,6 @@ class TasksController: UIViewController {
             }
         }
         
-        self.navigationItem.rightBarButtonItem = UIBarButtonItem(image: UIImage(systemName: "gear"), style: .plain, target: self, action: #selector(didTapSettings))
-        
         self.viewModel.onExpandCloseGroup = { [weak self] indexPaths, isOpening in
             DispatchQueue.main.async { [weak self] in
                 self?.tableView.performBatchUpdates({
@@ -73,6 +71,8 @@ class TasksController: UIViewController {
                 })
             }
         }
+        
+        self.navigationItem.rightBarButtonItem = UIBarButtonItem(image: UIImage(systemName: "gear"), style: .plain, target: self, action: #selector(didTapSettings))
     }
     
     
@@ -177,16 +177,15 @@ extension TasksController {
     
     func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
         tableView.deselectRow(at: indexPath, animated: true)
-        // TODO -
         let task = self.viewModel.taskGroups[indexPath.section].tasks[indexPath.row]
         let viewModel = ViewTaskControllerViewModel(task: task)
         let vc = ViewTaskController(viewModel: viewModel)
-//        vc.onTappedCompleteTask = { [weak self] in
-//            self?.viewModel.invertTaskCompleted(with: task)
-//            if !task.isCompleted {
-//                self?.showTasksCompletedPopup()
-//            }
-//        }
+        vc.onTappedCompleteTask = { [weak self] in
+            self?.viewModel.invertTaskCompleted(with: task)
+            if !task.isCompleted {
+                self?.showTaskCompletedPopup()
+            }
+        }
         let nav = UINavigationController(rootViewController: vc)
         nav.setupNavBarColor()
         self.present(nav, animated: true, completion: nil)
@@ -198,15 +197,31 @@ extension TasksController {
         
         let actionButtonTitle: String = isCompleted ? "Undo" : "Complete"
         
-        let action = UIContextualAction(style: .normal, title: actionButtonTitle) { aaaa, bbbb, completion in
+        let action = UIContextualAction(style: .normal, title: actionButtonTitle) { _, _, completion in
             self.viewModel.invertTaskCompleted(with: task)
             if !isCompleted {
-//                self.showTasksCompletedPopup()
+                self.showTaskCompletedPopup()
             }
         }
         action.backgroundColor = .systemBlue
         return UISwipeActionsConfiguration(actions: [action])
     }
+    
+    func tableView(_ tableView: UITableView, trailingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -> UISwipeActionsConfiguration? {
+
+        let edit = UIContextualAction(style: .normal, title: "Edit") { [weak self] _, _, _ in
+            guard let self = self else { return }
+            let task = self.viewModel.taskGroups[indexPath.section].tasks[indexPath.row]
+            self.didTapEditTask(for: task)
+        }
+
+        let delete = UIContextualAction(style: .destructive, title: "Delete") { [weak self] _, _, _ in
+            guard let self = self else { return }
+            let task = self.viewModel.taskGroups[indexPath.section].tasks[indexPath.row]
+            self.deleteTask(with: task)
+        }
+        return UISwipeActionsConfiguration(actions: [delete, edit])
+    }
 }
 
 
@@ -217,8 +232,10 @@ extension TasksController: TasksTableViewHeaderDelegate {
         let taskFormModel = TaskFormModel()
         let viewModel = TaskFormControllerViewModel(selectedDate: self.viewModel.selectedDate, taskFormModel: taskFormModel, originalTask: nil)
         let vc = TaskFormController(viewModel)
-        // TODO -
-//        vc.onCompleted = { [weak self] in self?.viewModel.refreshTasks() }
+        vc.onCompleted = { [weak self] in
+            guard let self = self else { return }
+            self.viewModel.fetchTasks(for: self.viewModel.selectedDate)
+        }
         self.navigationController?.pushViewController(vc, animated: true)
     }
     
@@ -238,14 +255,61 @@ extension TasksController: TasksTableViewHeaderDelegate {
         
         let viewModel = TaskFormControllerViewModel(selectedDate: self.viewModel.selectedDate, taskFormModel: taskFormModel, originalTask: task)
         let vc = TaskFormController(viewModel)
-        // TODO - 
-//        vc.onCompleted = { [weak self] in self?.viewModel.refreshTasks() }
+        
+        vc.onCompleted = { [weak self] in
+            guard let self = self else { return }
+            self.viewModel.fetchTasks(for: self.viewModel.selectedDate)
+        }
+        
         self.navigationController?.pushViewController(vc, animated: true)
     }
 }
 
+// MARK: - Delete Tasks
+extension TasksController {
+    
+    private func deleteTask(with task: Task) {
+        switch task {
+        case .persistent(_), .nonRepeating(_):
+            AlertManager.showDeleteTaskWarning(on: self) { [weak self] willContinue in
+                guard willContinue else { self?.viewModel.onUpdate?(); return }
+                self?.viewModel.deleteTask(for: task)
+            }
+            
+            return
+        case .repeating(let repeatingTask):
+            self.deleteRepeatingTask(for: repeatingTask)
+        }
+    }
+    
+    private func deleteRepeatingTask(for repeatingTask: RepeatingTask) {
+        AlertManager.showDeleteRepeatingTaskAlert(on: self) { [weak self] selectionOption in
+            guard let self = self else { return }
+            switch selectionOption {
+            case .allFuture:
+                self.viewModel.deleteRepeatingTaskForThisAndFutureDays(for: repeatingTask, selectedDate: self.viewModel.selectedDate)
+                break
+                
+            case .allTasks:
+                AlertManager.showCompletelyDeleteRepeatingTaskWarning(on: self) { [weak self] willContinue in
+                    if willContinue {
+                        self?.viewModel.completelyDeleteRepeatingTask(for: repeatingTask)
+                    } else {
+                        self?.viewModel.onUpdate?()
+                    }
+                }
+            case .cancel:
+                return
+            }
+        }
+    }
+}
+
 
 // MARK: - Show Task Completed Popup
 extension TasksController {
     
+    private func showTaskCompletedPopup() {
+        self.delegate?.showTaskCompletedPopup()
+    }
 }
diff --git a/TodoPad/Task Tab/TaskController/TasksControllerViewModel.swift b/TodoPad/Task Tab/TaskController/TasksControllerViewModel.swift
index 99ba1c2..0c311d8 100644
--- a/TodoPad/Task Tab/TaskController/TasksControllerViewModel.swift	
+++ b/TodoPad/Task Tab/TaskController/TasksControllerViewModel.swift	
@@ -156,7 +156,7 @@ extension TasksControllerViewModel {
             
             // TODO - Do check and invert in one function
             if alreadyCompleted {
-                self.repeatingTaskManager.deleteCompletedRepeatingTask(with: repeatingTask, for: selectedDate)
+                self.repeatingTaskManager.setTaskNotCompleted(with: repeatingTask, for: selectedDate)
             } else {
                 self.repeatingTaskManager.setTaskCompleted(with: repeatingTask, for: selectedDate)
             }
@@ -168,3 +168,39 @@ extension TasksControllerViewModel {
         self.fetchTasks(for: self.selectedDate)
     }
 }
+
+
+// MARK: - DeleteTask Functions
+extension TasksControllerViewModel {
+    
+    public func deleteTask(for task: Task) {
+        NotificationManager.removeNotifications(for: task)
+        
+        switch task {
+        case .persistent(let persistentTask):
+            self.persistentTaskManager.deletePersistentTask(with: persistentTask)
+            
+        case .repeating(_):
+            assertionFailure()
+            break
+            
+        case .nonRepeating(let nonRepeatingTask):
+            self.nonRepeatingTaskManager.deleteNonRepeatingTask(for: nonRepeatingTask)
+        }
+        
+        self.fetchTasks(for: self.selectedDate)
+    }
+    
+    public func deleteRepeatingTaskForThisAndFutureDays(for repeatingTask: RepeatingTask, selectedDate: Date) {
+        // TODO - Make this only delete notifications for days after self.selectedDate
+        NotificationManager.removeNotifications(for: Task.repeating(repeatingTask))
+        self.repeatingTaskManager.deleteThisAndFutureRepeatingTask(with: repeatingTask, deleteDate: selectedDate)
+        self.fetchTasks(for: selectedDate)
+    }
+    
+    public func completelyDeleteRepeatingTask(for repeatingTask: RepeatingTask) {
+        NotificationManager.removeNotifications(for: Task.repeating(repeatingTask))
+        self.repeatingTaskManager.completelyDeleteRepeatingTask(with: repeatingTask)
+        self.fetchTasks(for: self.selectedDate)
+    }
+}
diff --git a/TodoPad/Task Tab/TaskFormController/TaskFormController.swift b/TodoPad/Task Tab/TaskFormController/TaskFormController.swift
index 3a05c36..e10eff8 100644
--- a/TodoPad/Task Tab/TaskFormController/TaskFormController.swift	
+++ b/TodoPad/Task Tab/TaskFormController/TaskFormController.swift	
@@ -77,6 +77,7 @@ class TaskFormController: UIViewController {
             case .newTask:
                 self.saveNewTask(task: task)
             case .editTask:
+                if self.illegalExistingTaskChange(task: task) { return }
                 self.editExistingTask(task: task)
             }
             
@@ -95,7 +96,11 @@ class TaskFormController: UIViewController {
     }
     
     private func editExistingTask(task: Task) {
-        guard let originalTask = self.viewModel.originalTask else { return }
+        self.viewModel.editExistingTask(task: task)
+    }
+    
+    private func illegalExistingTaskChange(task: Task) -> Bool {
+        guard let originalTask = self.viewModel.originalTask else { return true }
         
         // If task enum type is not the same
         if !(originalTask ~= task) {
@@ -104,12 +109,11 @@ class TaskFormController: UIViewController {
                 firstTaskType: self.viewModel.originalTask!.typeOfTask,
                 secondTaskType: task.typeOfTask
             )
-            return
+            return true
         }
         
-        self.viewModel.editExistingTask(task: task)
+        return false
     }
-    
 }
 
 
diff --git a/TodoPad/Task Tab/TaskFormController/TaskFormControllerViewModel.swift b/TodoPad/Task Tab/TaskFormController/TaskFormControllerViewModel.swift
index c388e45..8809e15 100644
--- a/TodoPad/Task Tab/TaskFormController/TaskFormControllerViewModel.swift	
+++ b/TodoPad/Task Tab/TaskFormController/TaskFormControllerViewModel.swift	
@@ -43,6 +43,7 @@ class TaskFormControllerViewModel {
         selectedDate: Date,
         taskFormModel: TaskFormModel,
         originalTask: Task?,
+        
         persistentTaskManager: PersistentTaskManager = PersistentTaskManager(),
         repeatingTaskManager: RepeatingTaskManager = RepeatingTaskManager(),
         nonRepeatingTaskManager: NonRepeatingTaskManager = NonRepeatingTaskManager()
@@ -111,7 +112,7 @@ extension TaskFormControllerViewModel {
             case .repeats:
                 self.taskFormModel.repeatSettings = .daily
             case .endDate:
-                self.taskFormModel.endDate = self.selectedDate.endOfDay
+                self.taskFormModel.endDate = self.selectedDate.addingTimeInterval(60*60*24).startOfDay
             case .notifications:
                 self.taskFormModel.notificationsEnabled = true
             }
@@ -149,7 +150,7 @@ extension TaskFormControllerViewModel {
         self.removeAllOptionalTaskFormCells()
         self.setupConditionalCellsForStartDate()
         self.setupConditionalCellsForRepeatSettings()
-        self.updateIsEnabledCells()
+        self.updateIsEnabledForCells()
     }
     
     private func removeAllOptionalTaskFormCells() {
@@ -179,7 +180,7 @@ extension TaskFormControllerViewModel {
     }
     
     
-    private func updateIsEnabledCells() {
+    private func updateIsEnabledForCells() {
         // StartDate
         if self.taskFormModel.startDate != nil {
             if let index = self.taskFormCellModels[1].firstIndex(where: { $0.cellType == .startDate }) {
diff --git a/TodoPadTests/CoreData/RepeatingTaskManagerTests.swift b/TodoPadTests/CoreData/RepeatingTaskManagerTests.swift
index 30ec891..10654e2 100644
--- a/TodoPadTests/CoreData/RepeatingTaskManagerTests.swift
+++ b/TodoPadTests/CoreData/RepeatingTaskManagerTests.swift
@@ -193,7 +193,7 @@ extension RepeatingTaskManagerTests {
         XCTAssertFalse(isDayAfterCompleted)
     }
     
-    func testNonRepeatingTaskManager_DeleteCompletedRepeatingTask_DeletesCompletedTask() {
+    func testNonRepeatingTaskManager_SetTaskNotCompleted_DeletesCompletedTask() {
         // Arrange
         let rTask = self.rTask
         self.sut.saveNewRepeatingTask(with: rTask)
@@ -208,7 +208,7 @@ extension RepeatingTaskManagerTests {
         XCTAssertTrue(isNowCompleted)
         
         // Act
-        self.sut.deleteCompletedRepeatingTask(with: rTask, for: completedDate)
+        self.sut.setTaskNotCompleted(with: rTask, for: completedDate)
         
         // Assert
         let isDeleted = !self.sut.isTaskMarkedCompleted(with: rTask, for: completedDate)
diff --git a/TodoPadTests/TaskCompletedPopupTests.swift b/TodoPadTests/TaskCompletedPopupTests.swift
index 0c5c61b..ee90b7e 100644
--- a/TodoPadTests/TaskCompletedPopupTests.swift
+++ b/TodoPadTests/TaskCompletedPopupTests.swift
@@ -6,30 +6,33 @@
 //
 
 import XCTest
+@testable import TodoPad
 
 class TaskCompletedPopupTests: XCTestCase {
+    
+    var sut: TaskCompletedPopup!
 
     override func setUpWithError() throws {
-        // Put setup code here. This method is called before the invocation of each test method in the class.
+        self.sut = TaskCompletedPopup()
     }
 
     override func tearDownWithError() throws {
-        // Put teardown code here. This method is called after the invocation of each test method in the class.
+        self.sut = nil
     }
-
-    func testExample() throws {
-        // This is an example of a functional test case.
-        // Use XCTAssert and related functions to verify your tests produce the correct results.
-        // Any test you write for XCTest can be annotated as throws and async.
-        // Mark your test throws to produce an unexpected failure when your test encounters an uncaught error.
-        // Mark your test async to allow awaiting for asynchronous code to complete. Check the results with assertions afterwards.
+    
+    func testTaskCompletedPopup_WhenConfiguredWith1_Returns1() {
+        // Arrange & Act
+        self.sut.configure(tasksCompleted: 1)
+        
+        // Assert
+        XCTAssertEqual(self.sut.tasksCompletedLabel.text, 1.description + " Tasks Completed")
     }
-
-    func testPerformanceExample() throws {
-        // This is an example of a performance test case.
-        self.measure {
-            // Put the code you want to measure the time of here.
-        }
+    
+    func testTaskCompletedPopup_WhenConfiguredWith100_Returns100() {
+        // Arrange & Act
+        self.sut.configure(tasksCompleted: 100)
+        
+        // Assert
+        XCTAssertEqual(self.sut.tasksCompletedLabel.text, 100.description + " Tasks Completed")
     }
-
 }
diff --git a/TodoPadTests/TaskTab/TasksController/Mocks/MockTasksControllerDelegate.swift b/TodoPadTests/TaskTab/TasksController/Mocks/MockTasksControllerDelegate.swift
index 3ed46ea..80149fd 100644
--- a/TodoPadTests/TaskTab/TasksController/Mocks/MockTasksControllerDelegate.swift
+++ b/TodoPadTests/TaskTab/TasksController/Mocks/MockTasksControllerDelegate.swift
@@ -10,10 +10,21 @@ import XCTest
 
 class MockTasksControllerDelegate: TasksControllerDelegate {
     
+    var wasCalled: Bool = false
+    private var expectation: XCTestExpectation?
+    private let testCase: XCTestCase
     
+    init(testCase: XCTestCase) {
+        self.testCase = testCase
+    }
+    
+    func expect() {
+        expectation = testCase.expectation(description: "Expected showTaskCompletedPopup")
+    }
     
-    func showTasksCompletedPopup() {
-        // TODO - 
+    func showTaskCompletedPopup() {
+        self.wasCalled = true
+        self.expectation?.fulfill()
     }
 }
 
diff --git a/TodoPadTests/TaskTab/TasksController/Mocks/MockTasksTableViewHeaderDelegate.swift b/TodoPadTests/TaskTab/TasksController/Mocks/MockTasksTableViewHeaderDelegate.swift
index 6ba95e9..d7ed176 100644
--- a/TodoPadTests/TaskTab/TasksController/Mocks/MockTasksTableViewHeaderDelegate.swift
+++ b/TodoPadTests/TaskTab/TasksController/Mocks/MockTasksTableViewHeaderDelegate.swift
@@ -19,7 +19,7 @@ class MockTasksTableViewHeaderDelegate: TasksTableViewHeaderDelegate {
     }
     
     func expect() {
-        expectation = testCase.expectation(description: "Expect didTapAddNewTask")
+        expectation = testCase.expectation(description: "Expected didTapAddNewTask")
     }
     
     func didTapAddNewTask() {
diff --git a/TodoPadTests/TaskTab/TasksController/TasksControllerTests.swift b/TodoPadTests/TaskTab/TasksController/TasksControllerTests.swift
index b34cc6b..1eeac0c 100644
--- a/TodoPadTests/TaskTab/TasksController/TasksControllerTests.swift
+++ b/TodoPadTests/TaskTab/TasksController/TasksControllerTests.swift
@@ -220,6 +220,22 @@ extension TasksControllerTests {
 }
 
 // MARK: - Show Task Completed Popup
-extension TaskFormControllerTests {
-    // TODO - 
+extension TasksControllerTests {
+    
+    func testDidSelectRowAt_OnTappedCompleteTaskCallbackCalled_showTaskCompletedPopupDelegateFunctionCalled() {
+        // Arrange
+        let mockDelegate = MockTasksControllerDelegate(testCase: self)
+        self.sut.delegate = mockDelegate
+        
+        self.sut.tableView(self.sut.tableView, didSelectRowAt: IndexPath(row: 0, section: 0))
+        let viewTaskController = ((self.sut)?.spyPresentedViewController as? UINavigationController)?.topViewController as? ViewTaskController
+        
+        // Act
+        mockDelegate.expect()
+        viewTaskController?.didTapCompleteTask()
+        
+        // Assert
+        waitForExpectations(timeout: 3)
+        XCTAssertTrue(mockDelegate.wasCalled)
+    }
 }
diff --git a/TodoPadTests/TaskTab/TasksController/TasksControllerViewModelTests.swift b/TodoPadTests/TaskTab/TasksController/TasksControllerViewModelTests.swift
index c56771b..5eb99d5 100644
--- a/TodoPadTests/TaskTab/TasksController/TasksControllerViewModelTests.swift
+++ b/TodoPadTests/TaskTab/TasksController/TasksControllerViewModelTests.swift
@@ -291,3 +291,109 @@ extension TasksControllerViewModelTests {
         XCTAssertFalse(self.sut.isTaskCompleted(with: Task.persistent(pTask)))
     }
 }
+
+
+// MARK: - Delete Task Functions
+extension TasksControllerViewModelTests {
+    
+    func testDeleteTaskFunction_WhenNonRepeatingTask_DeletesRepeatingTaskFromCoreData() {
+        // Arrange
+        let nonRepTask = NonRepeatingTask.getMockNonRepeatingTask
+        self.nonRepTaskManager.saveNewNonRepeatingTask(with: nonRepTask)
+        
+        var nonRepTaskCount = self.nonRepTaskManager.fetchNonRepeatingTasks(for: nonRepTask.date).count
+        XCTAssertEqual(nonRepTaskCount, 1)
+        
+        // Act
+        self.sut.deleteTask(for: Task.nonRepeating(nonRepTask))
+        
+        // Assert
+        nonRepTaskCount = self.nonRepTaskManager.fetchNonRepeatingTasks(for: nonRepTask.date).count
+        XCTAssertEqual(nonRepTaskCount, 0)
+    }
+    
+    func testDeleteTaskFunction_WhenPersistentTask_DeletesPersistentTaskFromCoreData() {
+        // Arrange
+        let pTask = PersistentTask.getMockPersistentTask
+        self.pTaskManager.saveNewPersistentTask(with: pTask)
+        
+        var pTaskCount = self.pTaskManager.fetchAllPersistentTasks().count
+        XCTAssertEqual(pTaskCount, 1)
+        
+        // Act
+        self.sut.deleteTask(for: Task.persistent(pTask))
+        
+        // Assert
+        pTaskCount = self.pTaskManager.fetchAllPersistentTasks().count
+        XCTAssertEqual(pTaskCount, 0)
+    }
+    
+    func testDeleteRepeatingTaskForThisAndFutureDays_DeletesThisAndFutureDays() {
+        // Arrange
+        let rTask = RepeatingTask(
+            title: "rTask",
+            desc: nil,
+            taskUUID: UUID(),
+            isCompleted: false,
+            startDate: Date().addingTimeInterval(-14*60*60*24),
+            time: nil,
+            repeatSettings: .daily,
+            endDate: nil,
+            notificationsEnabled: false
+        )
+        self.rTaskManager.saveNewRepeatingTask(with: rTask)
+        
+        for x in -14...14 {
+            let tasks = self.rTaskManager.fetchRepeatingTasks(on: Date().addingTimeInterval(TimeInterval(x*60*60*24)))
+            XCTAssertEqual(tasks.count, 1)
+            XCTAssertNotNil(tasks.first, "Task should not have been nil \(x) from now. (Iteration \(x))")
+        }
+        
+        // Act
+        self.sut.deleteRepeatingTaskForThisAndFutureDays(for: rTask, selectedDate: Date().addingTimeInterval(7*60*60*24))
+        
+        // Assert
+        for x in -14...6 {
+            let tasks = self.rTaskManager.fetchRepeatingTasks(on: Date().addingTimeInterval(TimeInterval(x*60*60*24)))
+            XCTAssertEqual(tasks.count, 1)
+            XCTAssertNotNil(tasks.first, "Task should not have been nil \(x) from now. (Iteration \(x))")
+        }
+        for x in 7...14 {
+            let tasks = self.rTaskManager.fetchRepeatingTasks(on: Date().addingTimeInterval(TimeInterval(x*60*60*24)))
+            XCTAssertEqual(tasks.count, 0)
+            XCTAssertNil(tasks.first, "Task should have been nil \(x) from now. (Iteration \(x))")
+        }
+    }
+    
+    func testCompletelyDeleteRepeatingTask_CompletelyDeletesRepeatingTasksFromCoreData() {
+        // Arrange
+        let rTask = RepeatingTask(
+            title: "rTask",
+            desc: nil,
+            taskUUID: UUID(),
+            isCompleted: false,
+            startDate: Date().addingTimeInterval(-14*60*60*24),
+            time: nil,
+            repeatSettings: .daily,
+            endDate: nil,
+            notificationsEnabled: false
+        )
+        self.rTaskManager.saveNewRepeatingTask(with: rTask)
+        
+        for x in -14...14 {
+            let tasks = self.rTaskManager.fetchRepeatingTasks(on: Date().addingTimeInterval(TimeInterval(x*60*60*24)))
+            XCTAssertEqual(tasks.count, 1)
+            XCTAssertNotNil(tasks.first, "Task should not have been nil \(x) from now. (Iteration \(x))")
+        }
+        
+        // Act
+        self.sut.completelyDeleteRepeatingTask(for: rTask)
+        
+        // Assert
+        for x in -14...14 {
+            let tasks = self.rTaskManager.fetchRepeatingTasks(on: Date().addingTimeInterval(TimeInterval(x*60*60*24)))
+            XCTAssertEqual(tasks.count, 0)
+            XCTAssertNil(tasks.first, "Task should have been nil \(x) from now. (Iteration \(x))")
+        }
+    }
+}
